# C++学习笔记

## 数组

### C++将数组名参数视为数组第一个元素的地址
    //以下两个声明等价
    typename arr[];
    typename * arr;

## 函数

### 使用函数的三个步骤
提供函数原型、函数定义，并调用函数。

### 递归
    void countdown(int n)
    {
        cout << "Counting down ... " << n << endl;
        if (n > 0)
            countdown(n-1);
        cout << n << ":Kaboom!\n";
    }

### 函数指针
与直接调用函数相比，允许在不同的时间传递不同函数的地址，意味着可以在不同的时间使用不同的函数，允许每个程序员提供自己的算法。

    double pam(int);                         //声明函数
    double (*pf)(int);                       //声明指向函数的指针
    pf = pam;//pf指向pam()函数
    double x = pam(5);                       //通过函数名调用pam函数
    double y = (*pf)(4);                     //通过指针pf调用pam函数
    double z = pf(6);                        //C++允许这种情况
    void estimate(int i, double (*pf)(int))  //在其他函数中调用

### 内联函数

`inline`是C++语言中的一个关键字，可以用于程序中定义内联函数。**内联函数**是C++中的一种特殊函数，它可以像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是通过将函数体直接插入调用处来实现的，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。一般来说inline用于定义类的成员函数。
```C++
inline double square(double x)
{return x *x;}
//省略原型，将整个定义（即函数头及所有函数代码)放在原本应提供原型之处。
```
 > 优点：
 > 
> - inline 定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，（像宏一样展开），没有了调用的开销，效率也很高。
> - 编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。（宏替换不会检查参数类型，安全隐患较大）
> - inline函数可以作为一个类的成员函数，与类的普通成员函数作用相同，可以访问一个类的私有成员和保护成员。内联函数可以用于替代一般的宏定义，最重要的应用在于类的存取函数的定义上面。
> 
>   缺点：
>  
> - 内联函数不能包括复杂的控制语句，如循环语句和switch语句；   
> - 内联函数具有一定的局限性，内联函数的函数体一般来说不能太大。`inline`说明对编译器来说只是一种建议，编译器可以选择忽略这个建议。如果内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。

### 引用变量

#### 创建引用变量
    int rats;
    int & rodents = rats;            //int * const pr = &rats;
    // &rodents == &rats

#### 将引用用作函数参数
    //按值传递
    void sneezy(int x)
    //按引用传递
    void crumpy(int &x)
    //传递指针
    void swap(int * x)

#### 应尽可能将引用形参声明为const
- 避免无意中修改数据
- 能够处理const和非const实参
- 使函数能够正确生成并使用临时变量

#### 返回引用变量
返回引用的函数实际上是被引用的变量的别名

    //传统返回机制（按值传递）
    cout << sqrt(25);
    //等效于
    temp=sqrt(25)=5;
    cout << temp;

#### 将引用用于结构
    struct A
    {
        string name;
        int point;
    }

    A & function(a & one, a & two)
    {
        one.point += two.point;
        return one;
    }
使用引用变量避免将整个结构复制到一个临时位置

## 内存管理
- 在C++中规定了空结构体和空类的内存所占大小为1字节，因为c++中规定，任何不同的对象不能拥有相同的内存地址。
- 而在C语言中，空的结构体在内存中所占大小为0。(gcc中测试为0，其他编译器不一定)
