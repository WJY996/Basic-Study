# Java学习笔记
## 基本操作
### 异常处理机制(try,catch,finally)

Java通过面向对象的方法来处理例外。在一个方法的运行过程中，如果发生了例外，则这个方法生成代表该例外的一个对象，并把它交给运行时系统，运行时系统寻找相应的代码来处理这一例外。我们把生成例外对象并把它提交给运行时系统的过程称为**抛弃(throw)一个例外**。运行时系统在方法的调用栈中查找，从生成例外的方法开始进行回朔，直到找到包含相应例外处理的方法为止，这一个过程称为**捕获(catch)一个例外**。

    boolean test() throws Exception
    {
        try
        {
        //代码区
        }
        catch(Exception e)
        {
        //异常处理
        }
        finally
        {
        //提供统一出口,可进行资源的清除工作
        }
    }
代码区如果有错误，就会返回所写异常的处理。

如果try由于其他原因R突然中止（而非抛出异常v），那么finally块被执行，分为两种情况：
 
- 如果finally块执行顺利，那么整个try-catch-finally程序块的结局是“由于原因R突然中止（completes abruptly）”。
- 如果finally块由于原因S突然中止，那么整个try-catch-finally程序块的结局是“由于原因S突然中止（completes abruptly）”，原因R将被抛弃。


## JVM

###Java内存模型（JMM--Java Memory Model）
Java的内存模型可以理解为：在特定的协议下，对特定的内存和高级缓存进行读写访问的过程抽象，不同操作系统有不同的内存模型也就是过程抽象。Java虚拟机（JVM）也有自己的内存模型，也就是Java内存模型了。因为Java内存模型屏蔽了各种硬件和操作系统的差异，也就形成了大家众所周知的「 一次编写，到处运行 」。

Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。

Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面讲的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示。

![](./asset/java内存模型.jpg)
如上图所示，可以看出来内存交互中有八步的操作：lock、Unlock、Read、 Load、 Use、 Assign、 Store、 Write其中Read和Load  Store和Write必必须按顺序执行，而没有保证必须是连续执行。另外还有Java内存模型的八项规则：

- 不允许read和load、store和write操作之一单独出现
- 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
- 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。
